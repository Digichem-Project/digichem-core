# Objects for making cube files.

# General imports.
from pathlib import Path
import subprocess
import tempfile
import shutil
import os

# Silico imports.
from silico.exception.base import File_maker_exception
from silico.file import File_converter
import silico.file.types as file_types
import silico.log
from silico.submit.destination.local import Series
from silico.submit.calculation.turbomole import make_orbital_calc, Turbomole_memory,\
    make_anadens_calc
from silico.file.base import File_maker, Dummy_file_maker
from silico.submit.memory import Memory
from silico.misc.directory import copytree
from mako.lookup import TemplateLookup


class Fchk_to_cube(File_converter):
    """
    Class for handling file references to Gaussian cube files.
    
    We currently rely on Gaussian's cubegen facility to make cube files. There are a number of non-trivial problems with this approach:
     - Cubegen is part of the (very expensive) Gaussian package and so is not readily available on most machines used for post-processing.
     - The cubegen interface is poor, which makes effective error reporting particularly challenging.
     - Cubegen only takes .fchk files as input, while the rest of this analysis package reads the .log file.
       - .fchk files are not even generated by Gaussian automatically, they must be created from .chk files using another buggy Gaussian program: formchk
       - The requirement on these .fchk files is unnecessary as the data is also available in the .log file, but cubegen cannot read it.
    """
    
    # Text description of our input file type, used for error messages etc.
    #input_file_type = "fchk"
    input_file_type = file_types.gaussian_fchk_file
    # Text description of our output file type, used for error messages etc.
    output_file_type = file_types.gaussian_cube_file
    
    def __init__(self, *args, fchk_file = None, cubegen_type = "MO", orbital = "HOMO", npts = 0, cube_file = None, memory = None, cubegen_executable = "cubegen", **kwargs):
        """
        Constructor for Fchk_to_cube objects.
        
        See Image_maker for a full signature.
        
        :param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
        :param fchk_file: Optional fchk_file to use to generate this cube file.
        :param cubegen_type: The type of orbital that will be included in the cube file when we make it. Possible values are MO, AMO and BMO (for MO, alpha MO and beta MO respectively).
        :param orbital: The orbital to be included in the cube file when we make it. Possible values are 'HOMO', 'LUMO' or the integer level of the desired orbital.
        :param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
        :param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
        :param memory: The amount of memory for cubegen to use.
        """
        super().__init__(*args, input_file = fchk_file, existing_file = cube_file, **kwargs)
        self.cubegen_type = cubegen_type
        self.orbital = orbital
        self.npts = npts
        memory = memory if memory is not None else "3 GB"
        self.memory = Memory(memory)
        self.cubegen_executable = cubegen_executable
        
    @classmethod
    def from_options(self, output, *, fchk_file = None, cubegen_type = "MO", orbital = "HOMO", options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """        
        return self(
            output,
            fchk_file = fchk_file,
            cubegen_type = cubegen_type,
            orbital = orbital,
            npts = options['rendered_image']['orbital']['cube_grid_size'].to_gaussian(),
            dont_modify = not options['rendered_image']['enable_rendering'],
            cubegen_executable = options['external']['cubegen'],
            **kwargs
        )
            
    def make_files(self):
        """
        Make the files referenced by this object.
        """
        # The signature we'll use to call cubegen.
        signature = [
            "{}".format(self.cubegen_executable),
            "0",
            "{}={}".format(self.cubegen_type, self.orbital),
            str(self.input_file),
            str(self.output),
            str(self.npts)
        ]
        
        try:
            cubegen_proc =  subprocess.run(
                signature,
                # Capture both stdout and stderr.
                # It appears that cubegen writes everything (including error messages) to stdout, but it does return meaningful exit codes.
                stdout = subprocess.PIPE,
                stderr = subprocess.STDOUT,
                universal_newlines = True,
                env = dict(os.environ, GAUSS_MEMDEF = str(self.memory))
                )
        except FileNotFoundError:
            raise File_maker_exception(self, "Could not locate cubegen executable '{}'".format(self.cubegen_executable))
        
        # If something went wrong, dump output.
        if cubegen_proc.returncode != 0:
            # An error occured.
            raise File_maker_exception(self, "Cubegen did not exit successfully:\n{}".format(cubegen_proc.stdout))
        else:
            # Everything appeared to go ok.
            # Dump cubegen output if we're in debug.
            silico.log.get_logger().debug(cubegen_proc.stdout)



class Fchk_to_spin_cube(Fchk_to_cube):
    """
    A variation of the cube maker designed for making spin density cubes.
    
    Note that this class exists mainly for convenience; either class can be used to generate cubes of any supported type.
    """
    
    def __init__(self, *args, spin_density = "SCF", **kwargs):
        """
        Constructor for Fchk_to_cube objects.
        
        See Fchk_to_cube for a full signature.
        
        :param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
        :param fchk_file: Optional fchk_file to use to generate this cube file.
        :param spin_density: The density to use; you almost certainly want SCF unless perhaps you are using MP2...
        :param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
        :param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
        """
        return super().__init__(*args, cubegen_type = "Spin", orbital = spin_density, **kwargs)
    
    @classmethod
    def from_options(self, output, *, fchk_file = None, spin_density = "SCF", options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """        
        return self(
            output,
            fchk_file = fchk_file,
            spin_density = spin_density,
            npts = options['rendered_image']['spin']['cube_grid_size'].to_gaussian(),
            dont_modify = not options['rendered_image']['enable_rendering'],
            cubegen_executable = options['external']['cubegen'],
            **kwargs
        )
        
class Fchk_to_density_cube(Fchk_to_cube):
    """
    A variation of the cube maker designed for making density cubes.
    
    Note that this class exists mainly for convenience; either class can be used to generate cubes of any supported type.
    """
    
    def __init__(self, *args, density_type = "SCF", **kwargs):
        """
        Constructor for Fchk_to_cube objects.
        
        See Fchk_to_cube for a full signature.
        
        :param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
        :param fchk_file: Optional fchk_file to use to generate this cube file.
        :param density_type: The density to use.
        :param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
        :param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
        """
        super().__init__(*args, cubegen_type = "Density", orbital = density_type, **kwargs)
        self.type = density_type
    
    @classmethod
    def from_options(self, output, *, fchk_file = None, density_type = "SCF", options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """        
        return self(
            output,
            fchk_file = fchk_file,
            density_type = density_type,
            npts = options['rendered_image']['density']['cube_grid_size'].to_gaussian(),
            dont_modify = not options['rendered_image']['enable_rendering'],
            cubegen_executable = options['external']['cubegen'],
            **kwargs
        )

class Fchk_to_nto_cube(Fchk_to_cube):
    """
    A variation of the cube maker designed for making NTO cubes.
    
    Note that this class exists mainly for convenience; either class can be used to generate cubes of any supported type.
    """
    
    def __init__(self, *args, orbital = "HOMO", **kwargs):
        """
        Constructor for Fchk_to_cube objects.
        
        See Fchk_to_cube for a full signature.
        
        :param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
        :param fchk_file: Optional fchk_file to use to generate this cube file.
        :param orbital: The NTO to plot.
        :param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
        :param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
        """
        super().__init__(*args, cubegen_type = "MO", orbital = orbital, **kwargs)
    
    @classmethod
    def from_options(self, output, *, fchk_file = None, orbital = "HOMO", options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """        
        return self(
            output,
            fchk_file = fchk_file,
            orbital = orbital,
            npts = options['rendered_image']['natural_transition_orbital']['cube_grid_size'].to_gaussian(),
            dont_modify = not options['rendered_image']['enable_rendering'],
            cubegen_executable = options['external']['cubegen'],
            **kwargs
        )


class Gbw_to_cube(File_converter):
    """
    Class for converting from orca GBW files to Gaussian cube files.
    """
    
    # Text description of our input file type, used for error messages etc.
    #input_file_type = "fchk"
    input_file_type = file_types.orca_gbw_file
    # Text description of our output file type, used for error messages etc.
    output_file_type = file_types.gaussian_cube_file
    
    def __init__(self, *args, gbw_file = None, density_file = None, plot_type = 1, orbital = None, alpha_beta = 0, npts = None, cube_file = None, memory = None, prog_def, **kwargs):
        """
        Constructor for Fchk_to_cube objects.
        
        See Image_maker for a full signature.
        
        :param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
        :param gbw_file: gbw file to use to generate this cube file.
        :param density_file: density file to use to generate this cube file.
        :param plot_type: The property to plot. Common values are 1 = MO, 2 = SCF density, 3 = SCF spin density, 7 = mdci density, 8 = spin density, 11 = MP2 density.
        :param orbital: The orbital to be included in the cube file when we make it. This is the index of the orbital, starting at 0. Has no effect if we're not making an orbital cube.
        :param alpha_beta: Whether the orbital is spin-restricted (0), an alpha orbital (0) or a beta orbital (1).
        :param npts: The resolution of the cube grid. 50 is a typical default. None will use ORCA defaults.
        :param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
        :param memory: The amount of memory to use for rendering cubes.
        :param prog_def: An ORCA program definition to use to call orca_plot.
        """
        super().__init__(*args, input_file = gbw_file, existing_file = cube_file, **kwargs)
        self.density_file = density_file
        self.plot_type = plot_type
        self.orbital = orbital
        self.alpha_beta = alpha_beta
        self.npts = npts
        self.memory = Memory(memory) if memory is not None else None
        self.prog_def = prog_def
        
    def check_can_make(self):
        """
        Check whether it is feasible to try and create the files(s) that we represent.
        """
        # Check we have both a gbw and density file and that they exist.
        if self.input_file is None or not self.input_file.exists():
            raise File_maker_exception(self, "A .gbw file was not given or it does not exist")
        
        if self.density_file is None or not self.density_file.exists():
            raise File_maker_exception(self, "A .density file was not given or it does not exist")
        
    @classmethod
    def from_options(self, output, *, gbw_file = None, density_file = None, plot_type = 1, orbital = None, alpha_beta = 0, options, memory = None, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """
        # First, get our program.
        prog_def = options['report']['orca']['program']
        
        # Give up if no program available.
        if prog_def is None:
            return Dummy_file_maker(output, "No program definition is available (set the report: orca: program: option)")
        
        return self(
            output,
            gbw_file = gbw_file,
            density_file = density_file,
            plot_type = plot_type,
            orbital = orbital,
            alpha_beta = alpha_beta,
            npts = options['rendered_image']['orbital']['cube_grid_size'].to_orca(),
            dont_modify = not options['rendered_image']['enable_rendering'],
            prog_def = prog_def,
            memory = options['report']['orca']['memory'] if memory is None else memory,
            **kwargs
        )
            
    def make_files(self):
        """
        Make the files referenced by this object.
        """
        # Run in temp dir.
        with tempfile.TemporaryDirectory() as temp_dir:
            # Copy the gbw and density files to our input dir.
            # We need to make sure both files have the same root name.
            root_name = self.input_file.stem
            input_file = Path(temp_dir, root_name + ".gbw")
            shutil.copy(self.input_file, input_file)
            shutil.copy(self.density_file, Path(temp_dir, root_name + ".density"))
            
            # Get input options.
            input_str = TemplateLookup(directories = str(silico.default_template_directory())).get_template("/submit/orca/orca_plot.mako").render_unicode(gbw_to_cube = self)
            
            # Get signature.
            signature = ["orca_plot", str(input_file), "-i"]
            
            if self.memory is not None:
                signature.extend(("-m", self.memory.MB))
            
            try:
                orca_plot_proc =  subprocess.run(
                    signature,
                    input = input_str,
                    stdout = subprocess.PIPE,
                    stderr = subprocess.STDOUT,
                    universal_newlines = True,
                    # TOOD: This is a bit messy...
                    env = self.prog_def.inner_cls.get_env(self.prog_def.root, self.prog_def.mpi_root),
                    cwd = temp_dir
                )
            
            except FileNotFoundError:
                raise File_maker_exception(self, "Could not locate orca_plot executable '{}'".format(self.cubegen_executable))
        
            # If something went wrong, dump output.
            if orca_plot_proc.returncode != 0:
                # An error occured.
                raise File_maker_exception(self, "orca_plot did not exit successfully:\n{}".format(orca_plot_proc.stdout))
            else:
                # Everything appeared to go ok.
                # Dump orca_plot output if we're in debug.
                silico.log.get_logger().debug(orca_plot_proc.stdout)
                
            # Get our output file (a .cube file).
            # It's hard to know exactly what our output file will be called.
            # We can predict it based on what we asked for, but then we'd have to
            # implement a parsing method based on the options we gave to orca_plot.
            # Easier to just glob the .cube file (there should be only one).
            cube_files = list(Path(temp_dir).glob("*.cube"))
            
            # Check we got the number of files we expected.
            if len(cube_files) == 0:
                raise File_maker_exception(self, "orca_plot does not appear to have created the requested cube file, perhaps it was set up incorrectly?")
            
            elif len(cube_files) > 1:
                raise File_maker_exception(self, "orca_plot created '{}' cube files, but only one was expected".format(len(cube_files)))
            
            # Copy the cube file to our destination.
            shutil.move(cube_files[0], self.output, copy_function = shutil.copy)

# TODO: This module is fast becoming Turbomole centric, may be wise to move some of these classes somewhere else.
        
class Turbomole_to_orbital_cube(File_maker):
    """
    An adapter class that retrieves a single orbital cube from a Turbomole_to_cube object.
    """
    
    def __init__(self, *args, turbomole_to_cube, orbital, **kwargs):
        """
        Constructor for Turbomole_to_orbital_cube.
        
        :param turbomole_to_cube: A Turbomole_to_cube object.
        """
        self.turbomole_to_cube = turbomole_to_cube
        self.orbital = orbital
        super().__init__(turbomole_to_cube.path_for(orbital))
    
    def check_can_make(self):
        """
        Check whether it is feasible to try and create the files(s) that we represent.
        
        Reasons for making not being possible are varied and are up to the inheriting class, but include eg, a required input (cube, fchk) file not being given.
        
        This method returns nothing, but will raise an File_maker_exception exception if the rendering is not possible.
        """
        if self.orbital_label not in self.turbomole_to_cube:
            # Our cube maker wasn't setup to create this cube file.
            raise File_maker_exception(self, "Turbomole orbital cube maker was not setup to create cubes for '{}'".format(self.orbital_label))        
    
    def get_file(self, file = None):
        """
        """
        return self.turbomole_to_cube.get_file(self.orbital.sirrep)


class Turbomole_to_spin_cube(File_maker):
    """
    An adapter class that retrieves a spin density cube from a Turbomole_to_cube object.
    """
    
    def __init__(self, *args, turbomole_to_cube, **kwargs):
        """
        Constructor for Turbomole_to_orbital_cube.
        
        :param turbomole_to_cube: A Turbomole_to_cube object.
        :param irrep: 
        """
        self.turbomole_to_cube = turbomole_to_cube
        super().__init__(Path(turbomole_to_cube.output, 'sd.cub'))
    
    def check_can_make(self):
        """
        Check whether it is feasible to try and create the files(s) that we represent.
        
        Reasons for making not being possible are varied and are up to the inheriting class, but include eg, a required input (cube, fchk) file not being given.
        
        This method returns nothing, but will raise an File_maker_exception exception if the rendering is not possible.
        """
        if "spin" not in self.turbomole_to_cube:
            # Our cube maker wasn't setup to create this cube file.
            raise File_maker_exception(self, "Turbomole orbital cube maker was not setup to create spin density")
        
    def get_file(self, file = None):
        """
        """
        return self.turbomole_to_cube.get_file("spin")   


class Turbomole_to_density_cube(File_maker):
    """
    An adapter class that retrieves a total density cube from a Turbomole_to_cube object.
    """
    
    def __init__(self, *args, turbomole_to_cube, density_type = "SCF", **kwargs):
        """
        Constructor for Turbomole_to_orbital_cube.
        
        :param turbomole_to_cube: A Turbomole_to_cube object.
        :param irrep: 
        """
        self.type = density_type
        self.turbomole_to_cube = turbomole_to_cube
        super().__init__(Path(turbomole_to_cube.output, 'td.cub'))
    
    def check_can_make(self):
        """
        Check whether it is feasible to try and create the files(s) that we represent.
        
        Reasons for making not being possible are varied and are up to the inheriting class, but include eg, a required input (cube, fchk) file not being given.
        
        This method returns nothing, but will raise an File_maker_exception exception if the rendering is not possible.
        """
        if self.type not in self.turbomole_to_cube:
            # Our cube maker wasn't setup to create this cube file.
            raise File_maker_exception(self, "Turbomole orbital cube maker was not setup to create {} density".format(self.type))
        
    def get_file(self, file = None):
        """
        """
        return self.turbomole_to_cube.get_file(self.type)   


class Turbomole_to_cube(File_converter):
    """
    Class for converting Turbomole output to cube format.
    """
    
    # Text description of our input file type, used for error messages etc.
    input_file_type = "Turbomole Directory"
    # Text description of our output file type, used for error messages etc.
    output_file_type = file_types.gaussian_cube_file
    
    def __init__(self, *args, calculation_directory = None, calc_t, prog_t, orbitals = [], density, spin, silico_options, **kwargs):
        """
        Constructor for Turbomole_to_cube objects.
        
        See Image_maker for a full signature.
        
        :param output: Path to a directory in which the new cube files will be written.
        :param turbomole_calculation: A completed Turbomole calculation that will be used to generate cube files.
        :param orbitals: A list of orbitals to create cube files for.
        :param restricted: Whether the calculation is restricted or unrestricted HF.
        """
        super().__init__(*args, **kwargs)
        
        # Save our global silico options (we'll need it when creating our calcs).
        self.silico_options = silico_options
        
        # Save our input calc dir.
        self.input_file = Path(calculation_directory) if calculation_directory is not None else None
        
        # The orbitals we've been asked to make.
        self.orbitals = orbitals
        
        # Set paths to the cube files we'll be making.
        self.file_path = {orbital.sirrep: self.path_for(orbital) for orbital in self.orbitals}
        
        # Add densities.
        if spin:
            # Spin density.
            self.file_path['spin'] = Path(self.output, "sd.cub")
        if density:
            # Total density.
            self.file_path['SCF'] = Path(self.output, "td.cub")
        
        # Save our calculation, program and destination templates.
        # We use an in series destination so we will block while the calc runs.
        self.destination_t = Series(
            meta = {"name": "Orbital cubes"}
        )
        self.destination_t.finalize()
            
        # Given calc program.
        self.prog_t = prog_t
        
        # Given calc.
        self.calc_t = calc_t
        
    @classmethod
    def from_options(self, output, *args, calculation_directory = None, orbitals = [], density = True, spin = False, options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """
        # First, get our program.
        prog_t = options['report']['turbomole']['program']
        
        # Give up if no program available.
        if prog_t is None:
            return Dummy_file_maker(output, "No program definition is available (set the report: turbomole: program: option)")
        
        calculation_directory = calculation_directory.resolve() if calculation_directory is not None else None
        
        # Next, generate our calculation.
        calc_t = make_orbital_calc(
            name = calculation_directory,
            memory = Turbomole_memory(options['report']['turbomole']['memory']),
            num_cpu = options['report']['turbomole']['num_cpu'],
            orbitals = [orbital.total_level for orbital in orbitals],
            density = density or spin,
            # TODO: We have the usual turbomole problem here that we have to generate all our cubes together (both MO and density), so we need to decide which option to use.
            npts = options['rendered_image']['orbital']['cube_grid_size'].to_turbomole(),
            options = options
           )
        
        # And continue.
        return self(
            output,
            *args,
            calculation_directory = calculation_directory,
            calc_t = calc_t.inner_cls,
            prog_t = prog_t.inner_cls,
            orbitals = orbitals,
            density = density,
            spin = spin,
            dont_modify = not options['rendered_image']['enable_rendering'],
            silico_options = options,
            **kwargs
        )
        
    @classmethod
    def from_calculation(self, *args, turbomole_calculation, calculation_directory = None, orbitals = [], density = True, spin = False, options, **kwargs):
        """
        Create a Turbomole cube maker from an existing Turbomole calculation.
        """
        calc_t = turbomole_calculation.orbital_calc(orbitals = [orbital.total_level for orbital in orbitals], density = density or spin)
        
        return self(
            *args,
            calculation_directory = calculation_directory if calculation_directory is not None else turbomole_calculation.program.destination.calc_dir.output_directory,
            calc_t = calc_t.inner_cls,
            prog_t = type(turbomole_calculation.program),
            orbitals = orbitals,
            density = density,
            spin = spin,
            dont_modify = not options['rendered_image']['enable_rendering'],
            silico_options = options,
            **kwargs
        )
        
    def path_for(self, orbital):
        """
        """
        return Path(self.output, "{}.cub".format(orbital.sirrep))
        
    def make_files(self):
        """
        Make the files referenced by this object.
        """
        # To generate cubes, we need to run the dscf Turbomole module after setting some control options.
        
        # Link.
        destination = self.destination_t()
        prog = self.prog_t(destination)
        calc = self.calc_t(prog, global_silico_options = self.silico_options)
        
        # We'll write our calc to a sub folder of the output dir.
        # We'll delete it afterwards if all is well.
        # For the general Turbomole cube maker, our output is a dir (because we make lots of cubes at once).
        outdir = Path(self.output, "../")
        outdir.mkdir(parents = True, exist_ok = True)
        calc.prepare_from_directory(outdir, self.input_file, molecule_name = "Post")
        
        # Go.
        calc.submit()
        
        # Make our output dir.
        try:
            self.output.mkdir(parents = True)
        except FileExistsError:
            pass
        
        # Move created cube files to our output dir.
        for file, file_path in self.file_path.items():
            src = Path(destination.calc_dir.output_directory, file_path.name)
            dst = file_path
             
            # Can't use src.rename() because tmp may be on a different device.
            try:
                shutil.move(src, dst, copy_function = shutil.copy)
            except FileNotFoundError as e:
                # The requested cube wasn't where we expected; either the calculation didn't do what we ask, or the requested cube isn't made by the calc.
                raise File_maker_exception(self, "The requested cube file could not be found, perhaps it is not generated by this type of calculation?") from e
                
        # All went well, delete the dir.
        shutil.rmtree(str(destination.calc_dir))
                
                
class Turbomole_to_anadens_cube(File_converter):
    """
    Class for converting Turbomole calculation output to cubes generated by the $anadens data group.
    """
    
    # Text description of our input file type, used for error messages etc.
    input_file_type = "Turbomole Directory"
    # Text description of our output file type, used for error messages etc.
    output_file_type = file_types.gaussian_cube_file
    
    # The name of the two density files to calculate from.
    # We will always use the same file names because 'weird' characters (eg whitespace) will break Turbomole...)
    first_density_file_name = "first.cao"
    second_density_file_name = "second.cao"
    # The file name we'll ask the $anadens data group to write to.
    anadens_file_name = "anadens.cub"
    
    def __init__(self, *args, calculation_directory = None, first_density, second_density, calc_t, prog_t, silico_options, **kwargs):
        """
        Constructor for Turbomole_to_cube objects.
        
        See Image_maker for a full signature.
        
        :param output: Path to the file where the new cube file will be written.
        :param calculation_directory: Path to an existing and previously completed Turbomole calculation. At least one of the two density files should have been written by this calculation.
        :param first_density: Path to one of the two density files to calculate from.
        :param second_density: Path to the other of the two density files to calculate from.
        :param calc_t: The calculation template that will be run to calculate the new density.
        :param prog_t: The program template that will be run to calculate the new density.
        :param silico_options: Global silico options.
        """
        super().__init__(*args, input_file = calculation_directory, **kwargs)
        
        # Save our global silico options (we'll need it when creating our calcs).
        self.silico_options = silico_options
        
        # Also save the paths to the two density files (we'll need to copy these into the actual calc directory).
        self.first_density = first_density
        self.second_density = second_density
        
        # Save our calculation, program and destination templates.
        # We use an in series destination so we will block while the calc runs.
        self.destination_t = Series(
            meta = {"name": "Anadens cube"}
        )
        self.destination_t.finalize()
            
        # Given calc program.
        self.prog_t = prog_t
        
        # Given calc.
        self.calc_t = calc_t
        
    @classmethod
    def from_options(self, output, *args, calculation_directory, first_density, second_density, operator = "-",  options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """
        # First, get our program.
        prog_t = options['report']['turbomole']['program']
        
        # Give up if no program available.
        if prog_t is None:
            return Dummy_file_maker(output, "No program definition is available (set the report: turbomole: program: option)")
        
        calculation_directory = calculation_directory.resolve()
        
        # Next, generate our calculation.
        calc_t = make_anadens_calc(
            name = calculation_directory,
            memory = Turbomole_memory(options['report']['turbomole']['memory']),
            num_cpu = options['report']['turbomole']['num_cpu'],
            first_density = self.first_density_file_name,
            second_density = self.second_density_file_name,
            file_name = self.anadens_file_name,
            operator = operator
        )
        
        # And continue.
        return self(
            output,
            *args,
            calculation_directory = calculation_directory,
            first_density = first_density,
            second_density = second_density,
            calc_t = calc_t.inner_cls,
            prog_t = prog_t.inner_cls,
            silico_options = options,
            **kwargs
        )
        
    @classmethod
    def from_calculation(self, *args, turbomole_calculation, calculation_directory, first_density, second_density, operator = "-", options, **kwargs):
        """
        Create a Turbomole cube maker from an existing Turbomole calculation.
        """
        calc_t = turbomole_calculation.anadens_calc(self.first_density_file_name, self.second_density_file_name, self.anadens_file_name, operator)
        
        return self(
            *args,
            calculation_directory = calculation_directory if calculation_directory is not None else turbomole_calculation.program.destination.calc_dir.output_directory,
            first_density = first_density,
            second_density = second_density,
            calc_t = calc_t.inner_cls,
            prog_t = type(turbomole_calculation.program),
            silico_options = options,
            **kwargs
        )
        
    def make_files(self):
        """
        Make the files referenced by this object.
        """
        # Link.
        destination = self.destination_t()
        prog = self.prog_t(destination)
        calc = self.calc_t(prog, global_silico_options = self.silico_options)
        
        # We'll write our calc to a sub folder of the output dir.
        # We'll delete it afterwards if all is well.
        # For the anadens Turbomole cube maker, our output is a file (because we make only one cube at a time).
        outdir = Path(Path(self.output).parent, "../")
        outdir.mkdir(parents = True, exist_ok = True)
        calc.prepare_from_directory(outdir, self.input_file, molecule_name = "Post", additional_files = [(self.first_density, self.first_density_file_name), (self.second_density, self.second_density_file_name)])
        
        # Go.
        calc.submit()
        
        # Move the (hopefully) created output file to our real destination.
        try:
            src = Path(destination.calc_dir.output_directory, self.anadens_file_name)
            dst = self.output
            shutil.move(src, dst, copy_function = shutil.copy)
            
        except FileNotFoundError as e:
            raise File_maker_exception(self, "The requested anadens cube file could not be found, perhaps the calculation was setup incorrectly?") from e
        
        # All went well, delete the dir.
        shutil.rmtree(str(destination.calc_dir))
            