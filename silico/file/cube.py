# Objects for making cube files.

# General imports.
from pathlib import Path
import subprocess
from logging import getLogger

# Silico imports.
from silico.exception.base import File_maker_exception
from silico.file import File_converter
import silico.file.types as file_types
import silico
from silico.submit.method.local import Series
import tempfile

class Fchk_to_cube(File_converter):
	"""
	Class for handling file references to Gaussian cube files.
	
	We currently rely on Gaussian's cubegen facility to make cube files. There are a number of non-trivial problems with this approach:
	 - Cubegen is part of the (very expensive) Gaussian package and so is not readily available on most machines used for post-processing.
	 - The cubegen interface is poor, which makes effective error reporting particularly challenging.
	 - Cubegen only takes .fchk files as input, while the rest of this analysis package reads the .log file.
	   - .fchk files are not even generated by Gaussian automatically, they must be created from .chk files using another buggy Gaussian program: formchk
	   - The requirement on these .fchk files is unnecessary as the data is also available in the .log file, but cubegen cannot read it.
	"""
	
	# 'Path' to the cubegen executable.
	cubegen_executable = "cubegen"
	
	# Text description of our input file type, used for error messages etc.
	#input_file_type = "fchk"
	input_file_type = file_types.gaussian_fchk_file
	# Text description of our output file type, used for error messages etc.
	output_file_type = file_types.gaussian_cube_file
	
	def __init__(self, *args, fchk_file = None, cubegen_type = "MO", orbital = "HOMO", npts = 0, cube_file = None, **kwargs):
		"""
		Constructor for Fchk_to_cube objects.
		
		See Image_maker for a full signature.
		
		:param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
		:param fchk_file: Optional fchk_file to use to generate this cube file.
		:param cubegen_type: The type of orbital that will be included in the cube file when we make it. Possible values are MO, AMO and BMO (for MO, alpha MO and beta MO respectively).
		:param orbital: The orbital to be included in the cube file when we make it. Possible values are 'HOMO', 'LUMO' or the integer level of the desired orbital.
		:param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
		:param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
		"""
		super().__init__(*args, input_file = fchk_file, existing_file = cube_file, **kwargs)
		self.cubegen_type = cubegen_type
		self.orbital = orbital
		self.npts = npts
		
	@classmethod
	def from_options(self, output, *, fchk_file = None, cubegen_type = "MO", orbital = "HOMO", options, **kwargs):
		"""
		Constructor that takes a dictionary of config like options.
		"""		
		return self(
			output,
			fchk_file = fchk_file,
			cubegen_type = cubegen_type,
			orbital = orbital,
			npts = options['molecule_image']['orbital']['cube_grid_size'],
			dont_modify = options['image']['dont_modify'],
			**kwargs
		)
			
	def make_files(self):
		"""
		Make the files referenced by this object.
		"""
		# The signature we'll use to call cubegen.
		signature = [
			"{}".format(self.cubegen_executable),
			"0",
			"{}={}".format(self.cubegen_type, self.orbital),
			str(self.input_file),
			str(self.output),
			str(self.npts)
		]
		
		try:
			cubegen_proc =  subprocess.run(
				signature,
				# Capture both stdout and stderr.
				# It appears that cubegen writes everything (including error messages) to stdout, but it does return meaningful exit codes.
				stdout = subprocess.PIPE,
				stderr = subprocess.STDOUT,
				universal_newlines = True,
				)
		except FileNotFoundError:
			raise File_maker_exception(self, "Could not locate cubegen executable '{}'".format(self.cubegen_executable))
		
		# If something went wrong, dump output.
		if cubegen_proc.returncode != 0:
			# An error occured.
			raise File_maker_exception(self, "Cubegen did not exit successfully:\n{}".format(cubegen_proc.stdout))
		else:
			# Everything appeared to go ok.
			# Dump cubegen output if we're in debug.
			getLogger(silico.logger_name).debug(cubegen_proc.stdout)



class Fchk_to_spin_cube(Fchk_to_cube):
	"""
	A variation of the cube maker designed for making spin density cubes.
	
	Note that this class exists mainly for convenience; either class can be used to generate cubes of any supported type.
	"""
	
	def __init__(self, *args, spin_density = "SCF", **kwargs):
		"""
		Constructor for Fchk_to_cube objects.
		
		See Fchk_to_cube for a full signature.
		
		:param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
		:param fchk_file: Optional fchk_file to use to generate this cube file.
		:param spin_density: The density to use; you almost certainly want SCF unless perhaps you are using MP2...
		:param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
		:param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
		"""
		return super().__init__(*args, cubegen_type = "Spin", orbital = spin_density, **kwargs)
	
	@classmethod
	def from_options(self, output, *, fchk_file = None, spin_density = "SCF", options, **kwargs):
		"""
		Constructor that takes a dictionary of config like options.
		"""		
		return self(
			output,
			fchk_file = fchk_file,
			spin_density = spin_density,
			npts = options['molecule_image']['spin']['cube_grid_size'],
			dont_modify = options['image']['dont_modify'],
			**kwargs
		)
		
class Turbomole_cube_adapter():
	"""
	"""
	
	def __init__(self, turbomole_to_cube, irrep):
		"""
		"""
		self.turbomole_to_cube = turbomole_to_cube
		self.irrep = irrep
	
class Turbomole_to_cube(File_converter):
	"""
	Class for converting Turbomole output to cube format.
	"""
	
	# Text description of our input file type, used for error messages etc.
	input_file_type = "Turbomole Directory"
	# Text description of our output file type, used for error messages etc.
	output_file_type = file_types.gaussian_cube_file
	
	def __init__(self, *args, turbomole_calculation = None, orbitals = [], **kwargs):
		"""
		Constructor for Fchk_to_cube objects.
		
		See Image_maker for a full signature.
		
		:param output: Path to a directory in which the new cube files will be written.
		:param turbomole_calculation: A completed Turbomole calculation that will be used to generate cube files.
		:param orbitals: A list of orbital irreps (strings) to create cube files for.
		"""
		super().__init__(*args, **kwargs)
		
		# Save our input calc dir.
		self.turbomole_calculation = turbomole_calculation
		
		# The orbitals we've been asked to make.
		self.orbitals = [irrep.lower() for irrep in orbitals]
		
		# Set paths to the cube files we'll be making.
		self.file_path = {mo_irrep: Path(self.output, "{}.cub".format(mo_irrep)) for mo_irrep in self.orbitals}
	
	@property
	def input_file(self):
		"""
		"""
		if self.turbomole_calculation is None:
			return None
		else:
			return self.turbomole_calculation.program.method.calc_dir.output_directory
		
	def make_files(self):
		"""
		Make the files referenced by this object.
		"""
		# To generate cubes, we need to run the dscf Turbomole module after setting some control options.
		# We first need a method, program and calc we can use to make the files.
		# The calc is generated for us from the old calculation.
		calc_t = self.turbomole_calculation.orbital_calc()
		
		# We use the same program as the old calc too.
		prog_t = type(self.turbomole_calculation.program)
		
		# And we use an in series method so we will block while the calc runs.
		method_t = Series({"NAME": "Orbital cubes"}).configure(ID = None)
		
		
		# Now link them up.
		calc_t.finalize()
		prog_t.finalize()
		method_t.finalize()
		
		method = method_t()
		prog = prog_t(method)
		calc = calc_t(prog)
		
		# We'll write our calc to a tempdir.
		with tempfile.TemporaryDirectory() as tempdir:
			calc.prepare_from_calculation(tempdir, self.turbomole_calculation)
			
			# Go.
			try:
				calc.submit()
			except Exception as e:
				raise File_maker_exception(self, "Failed to make Turbomole cube files") from e
			
			# Move created cube files to our output dir.
			for mo_irrep in self.orbitals:
				src = Path(method.calc_dir.output_directory, "{}.cub".format(mo_irrep))
				dst = self.file_path[mo_irrep]
				
				src.rename(dst)
		
		