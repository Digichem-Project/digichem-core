# Objects for making cube files.

# General imports.
from pathlib import Path
import subprocess
import tempfile
import shutil
import os

# Silico imports.
from silico.exception.base import File_maker_exception
from silico.file import File_converter
import silico.file.types as file_types
import silico.logging
from silico.submit.destination.local import Series
from silico.submit.calculation.turbomole import make_orbital_calc, Turbomole_memory,\
    make_anadens_calc
from silico.file.base import File_maker
from silico.submit import Memory


class Fchk_to_cube(File_converter):
    """
    Class for handling file references to Gaussian cube files.
    
    We currently rely on Gaussian's cubegen facility to make cube files. There are a number of non-trivial problems with this approach:
     - Cubegen is part of the (very expensive) Gaussian package and so is not readily available on most machines used for post-processing.
     - The cubegen interface is poor, which makes effective error reporting particularly challenging.
     - Cubegen only takes .fchk files as input, while the rest of this analysis package reads the .log file.
       - .fchk files are not even generated by Gaussian automatically, they must be created from .chk files using another buggy Gaussian program: formchk
       - The requirement on these .fchk files is unnecessary as the data is also available in the .log file, but cubegen cannot read it.
    """
    
    # Text description of our input file type, used for error messages etc.
    #input_file_type = "fchk"
    input_file_type = file_types.gaussian_fchk_file
    # Text description of our output file type, used for error messages etc.
    output_file_type = file_types.gaussian_cube_file
    
    def __init__(self, *args, fchk_file = None, cubegen_type = "MO", orbital = "HOMO", npts = 0, cube_file = None, memory = None, cubegen_executable = "cubegen", **kwargs):
        """
        Constructor for Fchk_to_cube objects.
        
        See Image_maker for a full signature.
        
        :param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
        :param fchk_file: Optional fchk_file to use to generate this cube file.
        :param cubegen_type: The type of orbital that will be included in the cube file when we make it. Possible values are MO, AMO and BMO (for MO, alpha MO and beta MO respectively).
        :param orbital: The orbital to be included in the cube file when we make it. Possible values are 'HOMO', 'LUMO' or the integer level of the desired orbital.
        :param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
        :param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
        :param memory: The amount of memory for cubegen to use.
        """
        super().__init__(*args, input_file = fchk_file, existing_file = cube_file, **kwargs)
        self.cubegen_type = cubegen_type
        self.orbital = orbital
        self.npts = npts
        memory = memory if memory is not None else "3 GB"
        self.memory = Memory(memory)
        self.cubegen_executable = cubegen_executable
        
    @classmethod
    def from_options(self, output, *, fchk_file = None, cubegen_type = "MO", orbital = "HOMO", options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """        
        return self(
            output,
            fchk_file = fchk_file,
            cubegen_type = cubegen_type,
            orbital = orbital,
            npts = options['rendered_image']['orbital']['cube_grid_size'],
            dont_modify = not options['rendered_image']['enable_rendering'],
            cubegen_executable = options['external']['cubegen'],
            **kwargs
        )
            
    def make_files(self):
        """
        Make the files referenced by this object.
        """
        # The signature we'll use to call cubegen.
        signature = [
            "{}".format(self.cubegen_executable),
            "0",
            "{}={}".format(self.cubegen_type, self.orbital),
            str(self.input_file),
            str(self.output),
            str(self.npts)
        ]
        
        try:
            cubegen_proc =  subprocess.run(
                signature,
                # Capture both stdout and stderr.
                # It appears that cubegen writes everything (including error messages) to stdout, but it does return meaningful exit codes.
                stdout = subprocess.PIPE,
                stderr = subprocess.STDOUT,
                universal_newlines = True,
                env = dict(os.environ, GAUSS_MEMDEF = str(self.memory))
                )
        except FileNotFoundError:
            raise File_maker_exception(self, "Could not locate cubegen executable '{}'".format(self.cubegen_executable))
        
        # If something went wrong, dump output.
        if cubegen_proc.returncode != 0:
            # An error occured.
            raise File_maker_exception(self, "Cubegen did not exit successfully:\n{}".format(cubegen_proc.stdout))
        else:
            # Everything appeared to go ok.
            # Dump cubegen output if we're in debug.
            silico.logging.get_logger().debug(cubegen_proc.stdout)



class Fchk_to_spin_cube(Fchk_to_cube):
    """
    A variation of the cube maker designed for making spin density cubes.
    
    Note that this class exists mainly for convenience; either class can be used to generate cubes of any supported type.
    """
    
    def __init__(self, *args, spin_density = "SCF", **kwargs):
        """
        Constructor for Fchk_to_cube objects.
        
        See Fchk_to_cube for a full signature.
        
        :param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
        :param fchk_file: Optional fchk_file to use to generate this cube file.
        :param spin_density: The density to use; you almost certainly want SCF unless perhaps you are using MP2...
        :param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
        :param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
        """
        return super().__init__(*args, cubegen_type = "Spin", orbital = spin_density, **kwargs)
    
    @classmethod
    def from_options(self, output, *, fchk_file = None, spin_density = "SCF", options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """        
        return self(
            output,
            fchk_file = fchk_file,
            spin_density = spin_density,
            npts = options['rendered_image']['spin']['cube_grid_size'],
            dont_modify = not options['rendered_image']['enable_rendering'],
            cubegen_executable = options['external']['cubegen'],
            **kwargs
        )
        
class Fchk_to_density_cube(Fchk_to_cube):
    """
    A variation of the cube maker designed for making density cubes.
    
    Note that this class exists mainly for convenience; either class can be used to generate cubes of any supported type.
    """
    
    def __init__(self, *args, density_type = "SCF", **kwargs):
        """
        Constructor for Fchk_to_cube objects.
        
        See Fchk_to_cube for a full signature.
        
        :param output: The filename/path to the cube file (this path doesn't need to point to a real file yet; we will use this path to write to).
        :param fchk_file: Optional fchk_file to use to generate this cube file.
        :param density_type: The density to use.
        :param npts: The 'npts' option of cubegen, controls how detailed the resulting file is. Common options are 0 (default), -2 ('low' quality), -3 (medium quality), -4 (very high quality).
        :param cube_file: An optional file path to an existing cube file to use. If this is given (and points to an actual file), then a new cube will not be made and this file will be used instead.
        """
        super().__init__(*args, cubegen_type = "Density", orbital = density_type, **kwargs)
        self.type = density_type
    
    @classmethod
    def from_options(self, output, *, fchk_file = None, density_type = "SCF", options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """        
        return self(
            output,
            fchk_file = fchk_file,
            density_type = density_type,
            npts = options['rendered_image']['density']['cube_grid_size'],
            dont_modify = not options['rendered_image']['enable_rendering'],
            cubegen_executable = options['external']['cubegen'],
            **kwargs
        )
        

# TODO: This module is fast becoming Turbomole centric, may be wise to move some of these classes somewhere else.
        
class Turbomole_to_orbital_cube(File_maker):
    """
    An adapter class that retrieves a single orbital cube from a Turbomole_to_cube object.
    """
    
    def __init__(self, *args, turbomole_to_cube, orbital, **kwargs):
        """
        Constructor for Turbomole_to_orbital_cube.
        
        :param turbomole_to_cube: A Turbomole_to_cube object.
        :param irrep: 
        """
        self.turbomole_to_cube = turbomole_to_cube
        self.orbital = orbital
        super().__init__(turbomole_to_cube.path_for(orbital))
    
    def check_can_make(self):
        """
        Check whether it is feasible to try and create the files(s) that we represent.
        
        Reasons for making not being possible are varied and are up to the inheriting class, but include eg, a required input (cube, fchk) file not being given.
        
        This method returns nothing, but will raise an File_maker_exception exception if the rendering is not possible.
        """
        if self.orbital_label not in self.turbomole_to_cube:
            # Our cube maker wasn't setup to create this cube file.
            raise File_maker_exception(self, "Turbomole orbital cube maker was not setup to create cubes for '{}'".format(self.orbital_label))        
    
    def get_file(self, file = None):
        """
        """
        return self.turbomole_to_cube.get_file(self.orbital.sirrep)


class Turbomole_to_spin_cube(File_maker):
    """
    An adapter class that retrieves a spin density cube from a Turbomole_to_cube object.
    """
    
    def __init__(self, *args, turbomole_to_cube, **kwargs):
        """
        Constructor for Turbomole_to_orbital_cube.
        
        :param turbomole_to_cube: A Turbomole_to_cube object.
        :param irrep: 
        """
        self.turbomole_to_cube = turbomole_to_cube
        super().__init__(Path(turbomole_to_cube.output, 'sd.cub'))
    
    def check_can_make(self):
        """
        Check whether it is feasible to try and create the files(s) that we represent.
        
        Reasons for making not being possible are varied and are up to the inheriting class, but include eg, a required input (cube, fchk) file not being given.
        
        This method returns nothing, but will raise an File_maker_exception exception if the rendering is not possible.
        """
        if "spin" not in self.turbomole_to_cube:
            # Our cube maker wasn't setup to create this cube file.
            raise File_maker_exception(self, "Turbomole orbital cube maker was not setup to create spin density")
        
    def get_file(self, file = None):
        """
        """
        return self.turbomole_to_cube.get_file("spin")   


class Turbomole_to_density_cube(File_maker):
    """
    An adapter class that retrieves a total density cube from a Turbomole_to_cube object.
    """
    
    def __init__(self, *args, turbomole_to_cube, density_type = "SCF", **kwargs):
        """
        Constructor for Turbomole_to_orbital_cube.
        
        :param turbomole_to_cube: A Turbomole_to_cube object.
        :param irrep: 
        """
        self.type = density_type
        self.turbomole_to_cube = turbomole_to_cube
        super().__init__(Path(turbomole_to_cube.output, 'td.cub'))
    
    def check_can_make(self):
        """
        Check whether it is feasible to try and create the files(s) that we represent.
        
        Reasons for making not being possible are varied and are up to the inheriting class, but include eg, a required input (cube, fchk) file not being given.
        
        This method returns nothing, but will raise an File_maker_exception exception if the rendering is not possible.
        """
        if self.type not in self.turbomole_to_cube:
            # Our cube maker wasn't setup to create this cube file.
            raise File_maker_exception(self, "Turbomole orbital cube maker was not setup to create {} density".format(self.type))
        
    def get_file(self, file = None):
        """
        """
        return self.turbomole_to_cube.get_file(self.type)   


class Turbomole_to_cube(File_converter):
    """
    Class for converting Turbomole output to cube format.
    """
    
    # Text description of our input file type, used for error messages etc.
    input_file_type = "Turbomole Directory"
    # Text description of our output file type, used for error messages etc.
    output_file_type = file_types.gaussian_cube_file
    
    def __init__(self, *args, calculation_directory = None, calc_t, prog_t, orbitals = [], density, spin, silico_options, **kwargs):
        """
        Constructor for Turbomole_to_cube objects.
        
        See Image_maker for a full signature.
        
        :param output: Path to a directory in which the new cube files will be written.
        :param turbomole_calculation: A completed Turbomole calculation that will be used to generate cube files.
        :param orbitals: A list of orbitals to create cube files for.
        :param restricted: Whether the calculation is restricted or unrestricted HF.
        """
        super().__init__(*args, **kwargs)
        
        # Save our global silico options (we'll need it when creating our calcs).
        self.silico_options = silico_options
        
        # Save our input calc dir.
        self.input_file = Path(calculation_directory) if calculation_directory is not None else None
        
        # The orbitals we've been asked to make.
        self.orbitals = orbitals
        
        # Set paths to the cube files we'll be making.
        self.file_path = {orbital.sirrep: self.path_for(orbital) for orbital in self.orbitals}
        
        # Add densities.
        if spin:
            # Spin density.
            self.file_path['spin'] = Path(self.output, "sd.cub")
        if density:
            # Total density.
            self.file_path['SCF'] = Path(self.output, "td.cub")
        
        # Save our calculation, program and destination templates.
        # We use an in series destination so we will block while the calc runs.
        self.destination_t = Series(
            name = "Orbital cubes"
        )
        self.destination_t.finalize()
            
        # Given calc program.
        self.prog_t = prog_t
        
        # Given calc.
        self.calc_t = calc_t
        
    @classmethod
    def from_options(self, *args, calculation_directory = None, orbitals = [], density = True, spin = False, options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """
        # First, get our program.
        prog_t = options.programs.resolve(options['report']['turbomole']['program'])
        
        calculation_directory = calculation_directory.resolve() if calculation_directory is not None else None
        
        # Next, generate our calculation.
        calc_t = make_orbital_calc(
            name = calculation_directory,
            memory = Turbomole_memory(options['report']['turbomole']['memory']),
            num_CPUs = options['report']['turbomole']['num_CPUs'],
            orbitals = [orbital.total_level for orbital in orbitals],
            density = density or spin,
            options = options
           )
        
        # And continue.
        return self(
            *args,
            calculation_directory = calculation_directory,
            calc_t = calc_t.inner_cls,
            prog_t = prog_t.inner_cls,
            orbitals = orbitals,
            density = density,
            spin = spin,
            dont_modify = not options['rendered_image']['enable_rendering'],
            silico_options = options,
            **kwargs
        )
        
    @classmethod
    def from_calculation(self, *args, turbomole_calculation, calculation_directory = None, orbitals = [], density = True, spin = False, options, **kwargs):
        """
        Create a Turbomole cube maker from an existing Turbomole calculation.
        """
        calc_t = turbomole_calculation.orbital_calc(orbitals = [orbital.total_level for orbital in orbitals], density = density or spin)
        
        return self(
            *args,
            calculation_directory = calculation_directory if calculation_directory is not None else turbomole_calculation.program.destination.calc_dir.output_directory,
            calc_t = calc_t.inner_cls,
            prog_t = type(turbomole_calculation.program),
            orbitals = orbitals,
            density = density,
            spin = spin,
            dont_modify = not options['rendered_image']['enable_rendering'],
            silico_options = options,
            **kwargs
        )
        
    def path_for(self, orbital):
        """
        """
        return Path(self.output, "{}.cub".format(orbital.sirrep))
        
    def make_files(self):
        """
        Make the files referenced by this object.
        """
        # To generate cubes, we need to run the dscf Turbomole module after setting some control options.
        
        # Link.
        destination = self.destination_t()
        prog = self.prog_t(destination)
        calc = self.calc_t(prog, global_silico_options = self.silico_options)
        
        # We'll write our calc to a tempdir.
        with tempfile.TemporaryDirectory() as tempdir:
            calc.prepare_from_file(tempdir, self.input_file, molecule_name = "Orbitals")
            
            # Go.
            try:
                calc.submit()
            except Exception as e:
                raise File_maker_exception(self, "Failed to make Turbomole cube files") from e
            
            # Make our output dir.
            try:
                self.output.mkdir(parents = True)
            except FileExistsError:
                pass
            
            # Move created cube files to our output dir.
            for file, file_path in self.file_path.items():
                src = Path(destination.calc_dir.output_directory, file_path.name)
                dst = file_path
                 
                # Can't use src.rename() because tmp may be on a different device.
                try:
                    shutil.move(src, dst, copy_function = shutil.copy)
                except FileNotFoundError as e:
                    # The requested cube wasn't where we expected; either the calculation didn't do what we ask, or the requested cube isn't made by the calc.
                    raise File_maker_exception(self, "The requested cube file could not be found, perhaps it is not generated by this type of calculation?") from e
                
                
class Turbomole_to_anadens_cube(File_converter):
    """
    Class for converting Turbomole calculation output to cubes generated by the $anadens data group.
    """
    
    # Text description of our input file type, used for error messages etc.
    input_file_type = "Turbomole Directory"
    # Text description of our output file type, used for error messages etc.
    output_file_type = file_types.gaussian_cube_file
    
    # The name of the two density files to calculate from.
    # We will always use the same file names because 'weird' characters (eg whitespace) will break Turbomole...)
    first_density_file_name = "first.cao"
    second_density_file_name = "second.cao"
    # The file name we'll ask the $anadens data group to write to.
    anadens_file_name = "anadens.cub"
    
    def __init__(self, *args, calculation_directory = None, first_density, second_density, calc_t, prog_t, silico_options, **kwargs):
        """
        Constructor for Turbomole_to_cube objects.
        
        See Image_maker for a full signature.
        
        :param output: Path to the file where the new cube file will be written.
        :param calculation_directory: Path to an existing and previously completed Turbomole calculation. At least one of the two density files should have been written by this calculation.
        :param first_density: Path to one of the two density files to calculate from.
        :param second_density: Path to the other of the two density files to calculate from.
        :param calc_t: The calculation template that will be run to calculate the new density.
        :param prog_t: The program template that will be run to calculate the new density.
        :param silico_options: Global silico options.
        """
        super().__init__(*args, input_file = calculation_directory, **kwargs)
        
        # Save our global silico options (we'll need it when creating our calcs).
        self.silico_options = silico_options
        
        # Also save the paths to the two density files (we'll need to copy these into the actual calc directory).
        self.first_density = first_density
        self.second_density = second_density
        
        # Save our calculation, program and destination templates.
        # We use an in series destination so we will block while the calc runs.
        self.destination_t = Series(
            name = "Anadens cube"
        )
        self.destination_t.finalize()
            
        # Given calc program.
        self.prog_t = prog_t
        
        # Given calc.
        self.calc_t = calc_t
        
    @classmethod
    def from_options(self, *args, calculation_directory, first_density, second_density, operator = "-",  options, **kwargs):
        """
        Constructor that takes a dictionary of config like options.
        """
        # First, get our program.
        prog_t = options.programs.resolve(options['report']['turbomole']['program'])
        
        calculation_directory = calculation_directory.resolve()
        
        # Next, generate our calculation.
        calc_t = make_anadens_calc(
            name = calculation_directory,
            memory = Turbomole_memory(options['report']['turbomole']['memory']),
            num_CPUs = options['report']['turbomole']['num_CPUs'],
            first_density = self.first_density_file_name,
            second_density = self.second_density_file_name,
            file_name = self.anadens_file_name,
            operator = operator
        )
        
        # And continue.
        return self(
            *args,
            calculation_directory = calculation_directory,
            first_density = first_density,
            second_density = second_density,
            calc_t = calc_t.inner_cls,
            prog_t = prog_t.inner_cls,
            silico_options = options,
            **kwargs
        )
        
    @classmethod
    def from_calculation(self, *args, turbomole_calculation, calculation_directory, first_density, second_density, operator = "-", options, **kwargs):
        """
        Create a Turbomole cube maker from an existing Turbomole calculation.
        """
        calc_t = turbomole_calculation.anadens_calc(self.first_density_file_name, self.second_density_file_name, self.anadens_file_name, operator)
        
        return self(
            *args,
            calculation_directory = calculation_directory if calculation_directory is not None else turbomole_calculation.program.destination.calc_dir.output_directory,
            first_density = first_density,
            second_density = second_density,
            calc_t = calc_t.inner_cls,
            prog_t = type(turbomole_calculation.program),
            silico_options = options,
            **kwargs
        )
        
    def make_files(self):
        """
        Make the files referenced by this object.
        """
        # Link.
        destination = self.destination_t()
        prog = self.prog_t(destination)
        calc = self.calc_t(prog, global_silico_options = self.silico_options)
        
        # We'll write our calc to a tempdir.
        with tempfile.TemporaryDirectory() as tempdir:
            calc.prepare_from_file(tempdir, self.input_file, molecule_name = "Anadens", additional_files = [(self.first_density, self.first_density_file_name), (self.second_density, self.second_density_file_name)])
            
            # Go.
            try:
                calc.submit()
            except Exception as e:
                raise File_maker_exception(self, "Failed to make Turbomole cube files") from e
            
            # Move the (hopefully) created output file to our real destination.
            try:
                src = Path(destination.calc_dir.output_directory, self.anadens_file_name)
                dst = self.output
                shutil.move(src, dst, copy_function = shutil.copy)
                
            except FileNotFoundError as e:
                raise File_maker_exception(self, "The requested anadens cube file could not be found, perhaps the calculation was setup incorrectly?") from e
            